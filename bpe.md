# 从零开始构建字节对编码(BPE)分词器

BPE 算法最早由 Philip Gage 于 1994 年提出，详见：“[一种新的数据压缩算法](http://www.pennelynn.com/Documents/CUJ/HTML/94HTML/19940045.HTM)”。OpenAI 的开源 BPE 库 [tiktoken](https://github.com/openai/tiktoken)，因其卓越的性能，被广泛使用在大语言模型的分词器中，我将以 Karpathy 的 [minbpe](https://github.com/karpathy/minbpe) 为实现例子，详细阐述BPE算法的基本原理。

## 1、字节(Byte)与字符编码(UTF-8)

在介绍 BPE 算法之前，我们先来了解一下字节与字符编码的概念。

在计算机中，一个字节等于8个比特(bit)，比特是计算机最小的信息单位，只有0和1两种状态，所以，一个字节可以表示从00000000到11111111的二进制数，总共可以表示256种不同的状态（2的8次方）。比如，我们用字节来存储一个英文字母“A”，计算机内部会用一个字节来表示它，这个字节内部的二进制数可能是01000001。

UTF-8 编码是以字节为基本长度的变长 Unicode 编码方式，对于常见的英文字母和数字，UTF-8编码只需要1个字节来表示；而对于复杂的汉字或者其他语言的文字，可能需要2个、3个甚至4个字节来表示。UTF-8 编码的兼容性极好，它可以编码世界上的所有语言文字。

## 2、BPE的基本介绍

**BPE**算法的目标是构建一个包含常见子词（单词、词缀等等）的词汇表，每个词汇对应一个名为`Token ID`的独一无二的整数数字 ，通过词汇表将字节序列编码为`Token ID`序列，`Token ID`序列即为一个整数列表。

### 2.1、BPE算法大览

**1. 识别出现次数最多的字节对**
- 在每次迭代中，扫描文本，找到最常出现的字节对。

**2. 替换并记录**

- 用一个新的占位符 ID 替换该字节对（该 ID 尚未被使用，例如，如果我们从 0...255 开始，第一个占位符将是 256）。
- 将该映射记录在查找表中。
- 查找表的大小是一个超参数，称为“词汇表大小”（对于 GPT-2，这个值为 50,257）。

**3. 重复直到没有进一步优化**

- 持续执行步骤 1 和 2，反复合并最频繁的字节对。
- 当无法再进行压缩时停止（例如，没有字节对出现超过一次）。

**4.解压缩（解码）**

- 为恢复原始文本，通过查找表将每个 ID 替换为其对应的字节对，逆向执行此过程。

### 2.2、编码部分的具体示例

假设训练数据集`the cat in the hat`，我们希望为 BPE 分词器构建词汇表。

**第一次迭代**

**识别最多出现字节对**

  - 在这段文本中，"th" 出现了两次（分别位于开头和第二个 "e" 前）。

**替换并记录**

  - 将 "th" 替换为一个尚未使用的新的令牌 ID，例如 256。
  - 新的文本变为：`<256>e cat in <256>e hat`。
  - 新的词汇表如下：

```
  0: ...
  ...
  256: "th"
```

**第二次迭代**

**识别最多出现字节对**  

- 在文本 `<256>e cat in <256>e hat` 中，字节对 `<256>e` 出现了两次。

**替换并记录**  
- 将 `<256>e` 替换为一个尚未使用的新的token ID，例如 257。  
- 更新后的文本为：`<257> cat in <257> hat`。

  ```
  <257> cat in <257> hat
  ```
- 更新后的将会是
  ```
  0: ...
  ...
  256: "th"
  257: "<256>e"
  ```

**第三次迭代**

**识别最多出现字节对**  

- 在文本 `<257> cat in <257> hat` 中，字节对 `<257> ` 出现了两次（一次在开头，一次在“hat”之前）。

**替换并记录**  

- 将 `<257> ` 替换为一个尚未使用的新的token ID，例如 258。  
- 更新后的文本为：`<258>cat in <258>hat`。

  ```
  <258>cat in <258>hat
  ```
- The updated vocabulary is:
  ```
  0: ...
  ...
  256: "th"
  257: "<256>e"
  258: "<257> "
  ```

**如此循环**

### 2.3、解码部分的具体示例

- 为了恢复原始文本，我们通过逆向执行过程，将每个 token ID 替换为它对应的字节对，按它们引入的逆序进行替换。
- 从最终压缩后的文本开始：`<258>cat in <258>hat`
- 替换 `<258>` → `<257> `：`<257> cat in <257> hat`
- 替换 `<257>` → `<256>e`：`<256>e cat in <256>e hat`
- 替换 `<256>` → `"th"`：`the cat in the hat`


